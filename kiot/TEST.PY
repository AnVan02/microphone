import asyncio
import websockets
import numpy as np
import sounddevice as sd
import queue
import threading
import time
import sys
import argparse
import wave
import os 


# ========================
# âš™ï¸ Cáº¤U HÃŒNH NÃ‚NG CAO
# ========================
# SAMPLE_RATE = 16000  # Google Speech yÃªu cáº§u 16kHz
# CHANNELS = 1
# CHUNK_SIZE = 512  # Giáº£m Ä‘á»ƒ giáº£m latency
# BUFFER_SIZE = 100  # TÄƒng buffer Ä‘á»ƒ á»•n Ä‘á»‹nh hÆ¡n
SAMPLE_RATE = 48000
CHANNELS = 1 
BUFFER_SIZE = int(os.getenv ('MIC_BRIDGE_BUFFER', '256'))
VERBOSE = os.getenv('MIC_BRIDGE_VERBOSE' , '1') == '1'
last_print_time = time.time()

print("Danh sÃ¡ch thiáº¿t bá»‹ Ã¢m thanh :\n")
for i , d in enumerate(sd.query_devices()):
    marker = "(VB-CABLE)" if 'cable' in d['name']. lower() else ""
    print(f"[{i}] {d['name']}{marker}")
    print (f" Input: {d['max_input_channels']} | output: {d['max_output_channerls']}\n")


# Queue Ä‘á»ƒ lÆ°u audio
audio_queue = queue.Queue(maxsize=BUFFER_SIZE)
is_running = True

# ========================
# ğŸ¯ TÃŒM VÃ€ CHá»ŒN THIáº¾T Bá»Š Tá»° Äá»˜NG
# ========================
def find_audio_device():
    """TÃ¬m thiáº¿t bá»‹ audio phÃ¹ há»£p tá»± Ä‘á»™ng"""
    print("=" * 70)
    print("ğŸ§ ÄANG QUÃ‰T THIáº¾T Bá»Š Ã‚M THANH...")
    print("=" * 70)
    
    try:
        devices = sd.query_devices()
        
        # Æ¯u tiÃªn tÃ¬m VB-CABLE trÆ°á»›c
        cable_devices = []
        other_output_devices = []
        
        for i, device in enumerate(devices):
            name_lower = device['name'].lower()
            
            # Kiá»ƒm tra device cÃ³ output channels vÃ  hoáº¡t Ä‘á»™ng
            if device['max_output_channels'] > 0:
                if 'cable' in name_lower:
                    cable_devices.append((i, device))
                else:
                    other_output_devices.append((i, device))
        
        # Æ¯u tiÃªn VB-CABLE
        if cable_devices:
            print("âœ… TÃŒM THáº¤Y THIáº¾T Bá»Š CABLE:")
            for i, device in cable_devices:
                print(f"   [{i}] {device['name']} (Output: {device['max_output_channels']} channels)")
            return cable_devices[0][0]
        
        # Fallback: thiáº¿t bá»‹ output khÃ¡c
        if other_output_devices:
            print("âš ï¸ KHÃ”NG TÃŒM THáº¤Y CABLE, Sá»¬ Dá»¤NG THIáº¾T Bá»Š KHÃC:")
            for i, device in other_output_devices[:3]:  # Hiá»ƒn thá»‹ 3 thiáº¿t bá»‹ Ä‘áº§u
                print(f"   [{i}] {device['name']} (Output: {device['max_output_channels']} channels)")
            return other_output_devices[0][0]
            
        print("âŒ KHÃ”NG TÃŒM THáº¤Y THIáº¾T Bá»Š OUTPUT NÃ€O!")
        return None
        
    except Exception as e:
        print(f"âŒ Lá»–I KHI QUÃ‰T THIáº¾T Bá»Š: {e}")
        return None

# Tá»± Ä‘á»™ng chá»n device
DEVICE_ID = find_audio_device()

if DEVICE_ID is None:
    print("âŒ KHÃ”NG THá»‚ TÃŒM THáº¤Y THIáº¾T Bá»Š AUDIO PHÃ™ Há»¢P!")
    sys.exit(1)

# XÃ¡c nháº­n device Ä‘Ã£ chá»n
devices = sd.query_devices()
selected_device = devices[DEVICE_ID]
print(f"\nğŸ¯ ÄÃƒ CHá»ŒN THIáº¾T Bá»Š: [{DEVICE_ID}] {selected_device['name']}")
print(f"   ğŸ“Š Output Channels: {selected_device['max_output_channels']}")
print(f"   ğŸšï¸ Sample Rate: {SAMPLE_RATE} Hz")
print(f"   ğŸ”¢ Chunk Size: {CHUNK_SIZE} samples")

# ========================
# ğŸ“Š THEO DÃ•I HOáº T Äá»˜NG
# ========================
class AudioStats:
    def __init__(self):
        self.total_received = 0
        self.queue_drops = 0
        self.silent_frames = 0
        self.active_frames = 0
        self.last_print = time.time()
        self.audio_levels = []
        
    def update_audio_level(self, audio_data):
        """Cáº­p nháº­t má»©c Ä‘á»™ Ã¢m thanh"""
        if len(audio_data) > 0:
            rms = np.sqrt(np.mean(audio_data**2))
            self.audio_levels.append(rms)
            # Giá»¯ láº¡i 50 giÃ¡ trá»‹ gáº§n nháº¥t
            if len(self.audio_levels) > 50:
                self.audio_levels.pop(0)
            
            if rms > 0.01:
                self.active_frames += 1
                self.silent_frames = 0
                return "ğŸ”Š"
            else:
                self.silent_frames += 1
                return "ğŸ”‡"
        return "â“"
    
    def get_avg_audio_level(self):
        """Láº¥y má»©c Ã¢m thanh trung bÃ¬nh"""
        if self.audio_levels:
            return np.mean(self.audio_levels)
        return 0

audio_stats = AudioStats()
active_clients = set()

# ========================
# ğŸµ Xá»¬ LÃ AUDIO NÃ‚NG CAO
# ========================
def enhance_audio_for_speech(audio_data):
    """Xá»­ lÃ½ audio tá»‘i Æ°u cho speech recognition"""
    if len(audio_data) == 0:
        return audio_data
    
    # 1. Remove DC offset
    audio_data = audio_data - np.mean(audio_data)
    
    # 2. TÃ­nh RMS vÃ  Ä‘iá»u chá»‰nh gain
    rms = np.sqrt(np.mean(audio_data**2))
    
    if rms > 0:
        # 3. Dynamic gain adjustment
        target_rms = 0.3  # Má»©c target cho speech
        current_gain = target_rms / rms
        
        # Giá»›i háº¡n gain Ä‘á»ƒ trÃ¡nh distortion
        gain = np.clip(current_gain, 0.5, 3.0)
        audio_data = audio_data * gain
        
        # 4. Soft clipping Ä‘á»ƒ trÃ¡nh peak distortion
        clip_threshold = 0.9
        audio_data = np.tanh(audio_data * 1.2) * 0.8  # Soft clip
        
        # 5. High-pass filter Ä‘Æ¡n giáº£n (giáº£m low-frequency noise)
        if len(audio_data) > 1:
            alpha = 0.95
            audio_data[1:] = audio_data[1:] - alpha * audio_data[:-1]
    
    return audio_data

def resample_audio(audio_data, original_rate=48000, target_rate=16000):
    """Resample audio cháº¥t lÆ°á»£ng cao"""
    if len(audio_data) == 0:
        return audio_data
        
    if original_rate == target_rate:
        return audio_data
        
    # Tá»· lá»‡ resample
    ratio = original_rate / target_rate
    
    if ratio.is_integer():
        # Resample Ä‘Æ¡n giáº£n cho tá»· lá»‡ nguyÃªn
        return audio_data[::int(ratio)]
    else:
        # Linear interpolation cho tá»· lá»‡ khÃ´ng nguyÃªn
        original_indices = np.arange(len(audio_data))
        target_length = int(len(audio_data) / ratio)
        target_indices = np.linspace(0, len(audio_data)-1, target_length)
        return np.interp(target_indices, original_indices, audio_data)

# ========================
# ğŸ”Š AUDIO CALLBACK HOÃ€N CHá»ˆNH
# ========================
def audio_callback(outdata, frames, time_info, status):
    """Callback phÃ¡t audio - Tá»I Æ¯U CHO SPEECH"""
    global audio_stats
    
    if status:
        print(f"âš ï¸ Audio Status: {status}")
    
    try:
        # Láº¥y audio tá»« queue
        data = audio_queue.get_nowait()
        audio_stats.total_received += len(data)
        
        # Xá»­ lÃ½ kÃ­ch thÆ°á»›c khung
        if len(data) != frames:
            if len(data) < frames:
                # ThÃªm silence náº¿u thiáº¿u
                pad_length = frames - len(data)
                silence = np.zeros(pad_length, dtype=np.float32)
                data = np.concatenate([data, silence])
            else:
                data = data[:frames]
        
        # Ghi vÃ o output
        outdata[:, 0] = data
        
    except queue.Empty:
        # KhÃ´ng cÃ³ data - output silence
        outdata.fill(0)
        
        # Log náº¿u silence kÃ©o dÃ i nhÆ°ng cÃ³ client káº¿t ná»‘i
        current_time = time.time()
        if (len(active_clients) > 0 and 
            current_time - audio_stats.last_print > 3.0 and
            audio_stats.silent_frames > 10):
            print("ğŸ”‡ ÄANG CHá»œ Ã‚M THANH Tá»ª ÄIá»†N THOáº I...")
            audio_stats.last_print = current_time

# ========================
# ğŸ™ï¸ AUDIO STREAM MANAGER
# ========================
def audio_playback_thread():
    """Quáº£n lÃ½ audio stream - PHIÃŠN Báº¢N á»”N Äá»ŠNH"""
    global is_running
    
    print("\nğŸ”Š ÄANG KHá»I Äá»˜NG AUDIO STREAM...")
    
    max_retries = 3
    retry_count = 0
    
    while is_running and retry_count < max_retries:
        try:
            with sd.OutputStream(
                samplerate=SAMPLE_RATE,
                channels=CHANNELS,
                dtype=np.float32,
                device=DEVICE_ID,
                blocksize=CHUNK_SIZE,
                latency='low',
                callback=audio_callback
            ):
                print("âœ… AUDIO STREAM ÄÃƒ Sáº´N SÃ€NG!")
                print("ğŸ¯ ÄANG CHá»œ Ã‚M THANH Tá»ª ÄIá»†N THOáº I...")
                
                # Reset retry count khi káº¿t ná»‘i thÃ nh cÃ´ng
                retry_count = 0
                
                # VÃ²ng láº·p chÃ­nh
                while is_running:
                    time.sleep(0.05)  # Giáº£m sleep Ä‘á»ƒ responsive hÆ¡n
                    
                    # Log stats Ä‘á»‹nh ká»³
                    current_time = time.time()
                    if current_time - audio_stats.last_print > 8.0:
                        qsize = audio_queue.qsize()
                        clients_count = len(active_clients)
                        avg_level = audio_stats.get_avg_audio_level()
                        
                        status_icon = "âœ…" if clients_count > 0 else "â¸ï¸"
                        audio_icon = "ğŸ”Š" if avg_level > 0.02 else "ğŸ”‡"
                        
                        print(
                            f"ğŸ“Š {status_icon} Clients: {clients_count} | "
                            f"{audio_icon} Queue: {qsize}/{BUFFER_SIZE} | "
                            f"Drops: {audio_stats.queue_drops} | "
                            f"Level: {avg_level:.3f}"
                        )
                        audio_stats.last_print = current_time
                    
        except sd.PortAudioError as e:
            retry_count += 1
            print(f"âŒ Lá»—i Audio Stream (láº§n {retry_count}/{max_retries}): {e}")
            
            if retry_count < max_retries:
                print(f"ğŸ”„ Thá»­ láº¡i sau 3 giÃ¢y...")
                time.sleep(3)
            else:
                print("âŒ ÄÃ£ thá»­ láº¡i quÃ¡ sá»‘ láº§n cho phÃ©p!")
                break
                
        except Exception as e:
            print(f"âŒ Lá»—i khÃ´ng xÃ¡c Ä‘á»‹nh: {e}")
            break
    
    is_running = False
    print("ğŸ”´ AUDIO STREAM ÄÃƒ Dá»ªNG!")

# ========================
# ğŸŒ WEBSOCKET HANDLER HOÃ€N CHá»ˆNH
# ========================
async def handle_websocket(websocket):
    """Xá»­ lÃ½ WebSocket - Tá»I Æ¯U CHO REAL-TIME AUDIO"""
    global active_clients, audio_stats
    
    client_id = f"{websocket.remote_address[0]}:{websocket.remote_address[1]}"
    print(f"âœ… CLIENT Káº¾T Ná»I: {client_id}")
    active_clients.add(client_id)
    
    # Biáº¿n cá»¥c bá»™ cho client
    client_stats = {
        'frames_received': 0,
        'last_audio_time': time.time(),
        'audio_quality': 'unknown'
    }
    
    try:
        async for message in websocket:
            try:
                # Nháº­n audio data
                audio_data = np.frombuffer(message, dtype=np.float32)
                client_stats['frames_received'] += 1
                client_stats['last_audio_time'] = time.time()
                
                # Kiá»ƒm tra cháº¥t lÆ°á»£ng audio cÆ¡ báº£n
                if len(audio_data) > 0:
                    # Cáº­p nháº­t audio level
                    level_icon = audio_stats.update_audio_level(audio_data)
                    
                    # Xá»­ lÃ½ audio
                    processed_audio = enhance_audio_for_speech(audio_data)
                    
                    # Resample náº¿u cáº§n (giáº£ sá»­ input lÃ  48kHz)
                    if len(processed_audio) > 1000:  # Chá»‰ resample náº¿u audio Ä‘á»§ dÃ i
                        processed_audio = resample_audio(processed_audio, 48000, SAMPLE_RATE)
                    
                    # ÄÆ°a vÃ o queue
                    if not audio_queue.full():
                        audio_queue.put(processed_audio)
                    else:
                        # Queue Ä‘áº§y - xÃ³a frame cÅ© nháº¥t
                        try:
                            audio_queue.get_nowait()
                            audio_queue.put(processed_audio)
                            audio_stats.queue_drops += 1
                        except:
                            pass
                    
                    # Log chi tiáº¿t (giá»›i háº¡n táº§n suáº¥t)
                    if client_stats['frames_received'] % 100 == 0:
                        rms = np.sqrt(np.mean(processed_audio**2))
                        print(f"ğŸ“¥ {level_icon} {client_id}: {len(processed_audio)} samples | RMS: {rms:.4f}")
                        
            except Exception as e:
                print(f"âš ï¸ Lá»—i xá»­ lÃ½ audio tá»« {client_id}: {e}")
                
    except websockets.exceptions.ConnectionClosed:
        print(f"ğŸ”Œ CLIENT NGáº®T Káº¾T Ná»I: {client_id}")
    except Exception as e:
        print(f"âŒ Lá»—i WebSocket vá»›i {client_id}: {e}")
    finally:
        active_clients.discard(client_id)
        duration = time.time() - client_stats['last_audio_time']
        print(f"ğŸ“Š {client_id} disconnected | Frames: {client_stats['frames_received']} | Duration: {duration:.1f}s")

# ========================
# ğŸ› ï¸ TIá»†N ÃCH VÃ€ HÆ¯á»šNG DáºªN
# ========================
def print_system_checklist():
    """Checklist cáº¥u hÃ¬nh há»‡ thá»‘ng"""
    print("\n" + "=" * 80)
    print("ğŸ¯ CHECKLIST Cáº¤U HÃŒNH Há»† THá»NG")
    print("=" * 80)
    print("1. ğŸ™ï¸ CÃ€I Äáº¶T WINDOWS SOUND:")
    print("   â€¢ Má»Ÿ Settings > System > Sound")
    print("   â€¢ Input: Chá»n 'CABLE Output'")
    print("   â€¢ Click 'Set as Default' âœ…")
    print("   â€¢ Click 'Set as Default Communications Device' âœ…")
    print()
    print("2. ğŸŒ Cáº¤U HÃŒNH CHROME:")
    print("   â€¢ Má»Ÿ: chrome://settings/content/microphone")
    print("   â€¢ Cho phÃ©p website sá»­ dá»¥ng microphone")
    print("   â€¢ Chá»n 'CABLE Output' lÃ m microphone")
    print()
    print("3. ğŸ§ª TEST Há»† THá»NG:")
    print("   â€¢ Má»Ÿ: https://www.onlinemictest.com/")
    print("   â€¢ Cho phÃ©p sá»­ dá»¥ng microphone")
    print("   â€¢ NÃ³i thá»­ â†’ pháº£i tháº¥y thanh Ã¢m lÆ°á»£ng nháº£y")
    print()
    print("4. ğŸ” TEST GOOGLE VOICE SEARCH:")
    print("   â€¢ Má»Ÿ Google.com â†’ click biá»ƒu tÆ°á»£ng microphone")
    print("   â€¢ NÃ³i thá»­ â†’ pháº£i tháº¥y sÃ³ng Ã¢m thanh vÃ  nháº­n diá»‡n")
    print("=" * 80)

def check_system_requirements():
    """Kiá»ƒm tra yÃªu cáº§u há»‡ thá»‘ng"""
    print("\nğŸ” KIá»‚M TRA Há»† THá»NG...")
    
    # Kiá»ƒm tra Python version
    python_version = sys.version_info
    if python_version.major < 3 or (python_version.major == 3 and python_version.minor < 7):
        print("âŒ Python 3.7+ lÃ  báº¯t buá»™c!")
        return False
    
    # Kiá»ƒm tra port
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex(('localhost', 8765))
        if result == 0:
            print("âŒ Port 8765 Ä‘ang Ä‘Æ°á»£c sá»­ dá»¥ng!")
            sock.close()
            return False
        sock.close()
    except:
        pass
    
    print("âœ… Há»† THá»NG Äáº T YÃŠU Cáº¦U!")
    return True

# ========================
# ğŸš€ MAIN APPLICATION
# ========================
async def main():
    global is_running
    
    # Hiá»ƒn thá»‹ thÃ´ng tin á»©ng dá»¥ng
    print("\n" + "=" * 60)
    print("ğŸ™ï¸  WEBSOCKET TO VB-CABLE BRIDGE SERVER")
    print("=" * 60)
    print(f"ğŸ“¡ WebSocket: ws://0.0.0.0:8765")
    print(f"ğŸ”Š Output: [{DEVICE_ID}] {devices[DEVICE_ID]['name']}")
    print(f"ğŸšï¸ Sample Rate: {SAMPLE_RATE} Hz")
    print(f"ğŸ”¢ Channels: {CHANNELS}")
    print("=" * 60)
    
    # Hiá»ƒn thá»‹ checklist
    print_system_checklist()
    
    # Kiá»ƒm tra há»‡ thá»‘ng
    if not check_system_requirements():
        print("âŒ KHÃ”NG THá»‚ KHá»I Äá»˜NG SERVER!")
        return
    
    # Khá»Ÿi Ä‘á»™ng audio thread
    print("\nğŸš€ ÄANG KHá»I Äá»˜NG Há»† THá»NG...")
    audio_thread = threading.Thread(target=audio_playback_thread, daemon=True)
    audio_thread.start()
    
    # Chá» audio stream khá»Ÿi Ä‘á»™ng
    time.sleep(2)
    
    print("\nğŸ“± HÆ¯á»šNG DáºªN Sá»¬ Dá»¤NG:")
    print("1. Má»Ÿ file microphone.php trÃªn trÃ¬nh duyá»‡t PC")
    print("2. DÃ¹ng Ä‘iá»‡n thoáº¡i quÃ©t QR code Ä‘á»ƒ káº¿t ná»‘i")
    print("3. NÃ³i vÃ o Ä‘iá»‡n thoáº¡i â†’ Ã¢m thanh vÃ o CABLE Output")
    print("4. Má»Ÿ website cáº§n speech recognition Ä‘á»ƒ test")
    
    print("\nâš¡ TRáº NG THÃI:")
    print("   â€¢ Audio Stream: âœ… ÄÃ£ khá»Ÿi Ä‘á»™ng")
    print("   â€¢ WebSocket Server: âœ… Äang chá» káº¿t ná»‘i...")
    print("   â€¢ VB-Cable Bridge: âœ… Sáºµn sÃ ng")
    
    print("\nâ¹ï¸ Nháº¥n Ctrl+C Ä‘á»ƒ dá»«ng server\n")
    
    try:
        # Khá»Ÿi Ä‘á»™ng WebSocket server
        server = await websockets.serve(
            handle_websocket, 
            "0.0.0.0", 
            8765, 
            ping_interval=20,
            ping_timeout=30,
            close_timeout=10
        )
        
        print("ğŸ¯ SERVER ÄÃƒ Sáº´N SÃ€NG!")
        print("ğŸ”„ Äang chá» káº¿t ná»‘i tá»« Ä‘iá»‡n thoáº¡i...")
        
        # Giá»¯ server cháº¡y
        await asyncio.Future()
            
    except KeyboardInterrupt:
        print("\nğŸ›‘ NHáº¬N TÃN HIá»†U Dá»ªNG...")
    except Exception as e:
        print(f"âŒ Lá»–I SERVER: {e}")
        import traceback
        traceback.print_exc()
    finally:
        is_running = False
        print("ğŸ‘‹ SERVER ÄÃƒ Dá»ªNG HOÃ€N TOÃ€N")

if __name__ == "__main__":
    # Parse arguments
    parser = argparse.ArgumentParser(description='WebSocket to VB-CABLE Audio Bridge')
    parser.add_argument('--port', type=int, default=8765, help='WebSocket port (default: 8765)')
    parser.add_argument('--sample-rate', type=int, default=16000, help='Sample rate (default: 16000)')
    parser.add_argument('--chunk-size', type=int, default=512, help='Chunk size (default: 512)')

    args = parser.parse_args()
    
    # Cáº­p nháº­t cáº¥u hÃ¬nh tá»« arguments
    SAMPLE_RATE = args.sample_rate
    CHUNK_SIZE = args.chunk_size
    
    try:
        # Import socket cho port check
        import socket
        
        # Cháº¡y á»©ng dá»¥ng
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nğŸ¯ SERVER ÄÃƒ Dá»ªNG THEO YÃŠU Cáº¦U")
    except Exception as e:
        print(f"âŒ Lá»–I KHá»I Äá»˜NG: {e}")
        import traceback
        traceback.print_exc()